// Global variables
let currentDiscussions = [];
let currentDiscussion = null;
let searchTimeout = null;

console.log('🚀 토론 게시판 v2.0 로드됨 - ', new Date().toLocaleString());
let currentFilters = {
    search: '',
    sort: 'recent',
    type: ''
};

// 로컬 스토리지에 저장된 토론방 데이터
let localDiscussions = JSON.parse(localStorage.getItem('localDiscussions') || '[]');

// Sample data for fallback - 비어있음 (초기 화면에 아무것도 표시하지 않음)
const sampleDiscussions = [];

// DOM Elements
const loadingOverlay = document.getElementById('loadingOverlay');
const discussionsGrid = document.getElementById('discussionsGrid');
const emptyState = document.getElementById('emptyState');
const searchInput = document.getElementById('searchInput');
const sortSelect = document.getElementById('sortSelect');
const typeFilter = document.getElementById('typeFilter');
const newDiscussionModal = document.getElementById('newDiscussionModal');
const discussionDetailModal = document.getElementById('discussionDetailModal');
const toast = document.getElementById('toast');

// Statistics elements (removed - no longer used)

// Initialize app
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
    setupEventListeners();
});

async function initializeApp() {
    showLoading();
    try {
        await loadDiscussions();
    } catch (error) {
        console.error('앱 초기화 오류:', error);
        showToast('앱을 초기화하는 중 오류가 발생했습니다.', 'error');
    } finally {
        hideLoading();
    }
}

function setupEventListeners() {
    // Search input
    searchInput.addEventListener('input', handleSearch);

    // Sort and filter
    sortSelect.addEventListener('change', handleSortChange);
    typeFilter.addEventListener('change', handleTypeFilter);

    // New discussion form
    const newDiscussionForm = document.getElementById('newDiscussionForm');
    newDiscussionForm.addEventListener('submit', handleNewDiscussion);

    // Opinion form - event listener registered in DOMContentLoaded (line 1273)

    // Modal close on outside click
    newDiscussionModal.addEventListener('click', (e) => {
        if (e.target === newDiscussionModal) {
            closeNewDiscussionModal();
        }
    });

    discussionDetailModal.addEventListener('click', (e) => {
        if (e.target === discussionDetailModal) {
            closeDiscussionDetailModal();
        }
    });

    // Auto-refresh discussions every 30 seconds
    setInterval(loadDiscussions, 30000);

    // 모드 변경 이벤트
    const modeRadios = document.querySelectorAll('input[name="discussionMode"]');
    modeRadios.forEach(radio => {
        radio.addEventListener('change', handleModeChange);
    });

    // 기간 선택 이벤트
    const durationSelect = document.getElementById('discussionDuration');
    if (durationSelect) {
        durationSelect.addEventListener('change', handleDurationChange);
    }

    // 비밀글 토글 이벤트
    const privateToggle = document.getElementById('isPrivateDiscussion');
    if (privateToggle) {
        privateToggle.addEventListener('change', handlePrivateToggle);
    }

    // 입장코드 입력란에서 Enter 키 이벤트
    const entryCodeInput = document.getElementById('entryCodeInput');
    if (entryCodeInput) {
        entryCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                verifyEntryCode();
            }
        });
    }

    // 토론 제목 입력 시 자동 AI 설명 생성
    const discussionTitle = document.getElementById('discussionTitle');
    let titleTimeout = null;
    discussionTitle.addEventListener('input', (e) => {
        clearTimeout(titleTimeout);
        titleTimeout = setTimeout(() => {
            const title = e.target.value.trim();
            if (title && title.length > 3) {
                autoGenerateDescription(title);
            }
        }, 1500); // 1.5초 후 자동 생성
    });
}

// Loading functions
function showLoading() {
    loadingOverlay.classList.remove('hidden');
}

function hideLoading() {
    loadingOverlay.classList.add('hidden');
}

// API functions
async function apiRequest(url, options = {}) {
    try {
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP ${response.status}`);
        }

        return await response.json();
    } catch (error) {
        console.error('API 요청 오류:', error);
        throw error;
    }
}

async function loadDiscussions() {
    console.log('토론 목록 로드 시작...');

    try {
        // API로부터 데이터 로드
        const response = await fetch(`/api/discussions?search=${encodeURIComponent(currentFilters.search)}&sort=${currentFilters.sort}&type=${encodeURIComponent(currentFilters.type)}`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const discussions = await response.json();
        currentDiscussions = discussions;
        // API 데이터를 localDiscussions와 동기화
        localDiscussions = discussions;
        localStorage.setItem('localDiscussions', JSON.stringify(localDiscussions));

        console.log('API로부터 토론 목록 로드 완료, 총', discussions.length, '개의 토론방');
        renderDiscussions();

    } catch (error) {
        console.error('API 호출 실패, 로컬 스토리지 폴백:', error);

        // API 실패 시 로컬 스토리지 폴백
        localDiscussions = JSON.parse(localStorage.getItem('localDiscussions') || '[]');
        let discussions = [...localDiscussions];

        // 검색 필터 적용
        if (currentFilters.search) {
            const searchLower = currentFilters.search.toLowerCase();
            discussions = discussions.filter(d =>
                d.title.toLowerCase().includes(searchLower) ||
                d.author.toLowerCase().includes(searchLower) ||
                d.type.toLowerCase().includes(searchLower)
            );
        }

        // 정렬 적용
        if (currentFilters.sort === 'participants') {
            discussions.sort((a, b) => b.participants - a.participants);
        } else {
            discussions.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        }

        // 타입 필터 적용
        if (currentFilters.type) {
            currentDiscussions = discussions.filter(d => d.type === currentFilters.type);
        } else {
            currentDiscussions = discussions;
        }

        console.log('로컬 스토리지 폴백으로 토론 목록 로드 완료, 총', currentDiscussions.length, '개의 토론방');
        renderDiscussions();
    }
}

function renderDiscussions() {
    console.log('토론방 렌더링 시작, 토론 수:', currentDiscussions.length);

    if (currentDiscussions.length === 0) {
        console.log('토론방이 없어서 빈 상태 표시');
        discussionsGrid.style.display = 'none';
        emptyState.style.display = 'block';
        return;
    }

    console.log('토론방 카드 렌더링 중...');
    discussionsGrid.style.display = 'grid';
    emptyState.style.display = 'none';

    discussionsGrid.innerHTML = currentDiscussions.map(discussion => `
        <div class="discussion-card" onclick="window.location.href='room.html?id=${discussion.id}'">
            <div class="card-header">
                <h3 class="discussion-title">
                    ${discussion.is_private === true ? '<i class="fas fa-lock"></i> ' : ''}${escapeHtml(discussion.title)}
                </h3>
                <div class="type-badge ${discussion.type}">${discussion.type}</div>
                <div class="card-actions">
                    ${renderActionButtons(discussion)}
                </div>
            </div>

            <div class="card-meta">
                <div class="meta-item author-info">
                    <i class="fas fa-user"></i>
                    <span>개설자: ${escapeHtml(discussion.author)}</span>
                </div>
                <div class="meta-item participants-info">
                    <i class="fas fa-users"></i>
                    <span>실시간 참여 인원: ${discussion.participants}명</span>
                </div>
            </div>

            <div class="time-remaining">
                <i class="fas fa-clock"></i>
                <span>삭제까지: ${discussion.timeRemaining} 남음</span>
            </div>
        </div>
    `).join('');

    console.log('토론방 카드 렌더링 완료');
}

// Statistics function removed - no longer needed

// Search and filter functions
function handleSearch(e) {
    const value = e.target.value.trim();

    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        currentFilters.search = value;
        loadDiscussions();
    }, 300);
}

function handleSortChange(e) {
    currentFilters.sort = e.target.value;
    loadDiscussions();
}

function handleTypeFilter(e) {
    currentFilters.type = e.target.value;
    loadDiscussions();
}

// Modal functions
function openNewDiscussionModal() {
    newDiscussionModal.classList.add('active');
    document.body.style.overflow = 'hidden';
}

function closeNewDiscussionModal() {
    newDiscussionModal.classList.remove('active');
    document.body.style.overflow = '';

    // Reset form
    const newDiscussionForm = document.getElementById('newDiscussionForm');
    newDiscussionForm.reset();

    // 수정 모드 해제
    delete newDiscussionForm.dataset.editMode;
    delete newDiscussionForm.dataset.editId;

    // 모달 타이틀 원복
    document.querySelector('#newDiscussionModal h2').textContent = '새 토론 시작하기';

    // 제출 버튼 텍스트 원복
    document.querySelector('#newDiscussionForm button[type="submit"]').textContent = '생성';

    // 숨겨진 섹션들 초기화
    document.getElementById('prosConsSection').style.display = 'none';
    document.getElementById('roleSection').style.display = 'none';
    document.getElementById('customDurationSection').style.display = 'none';
}

async function openDiscussionDetail(id, skipPrivateCheck = false) {
    try {
        showLoading();
        console.log('토론 상세 정보 로드:', id);

        // 서버에서 최신 토론 정보 가져오기
        let discussion;
        try {
            const response = await fetch(`/api/discussions/${id}`);
            if (response.ok) {
                discussion = await response.json();
                console.log('서버에서 토론 정보 로드:', discussion);
            } else {
                throw new Error('서버에서 토론을 찾을 수 없습니다.');
            }
        } catch (error) {
            console.error('서버 API 호출 실패, 로컬 스토리지 폴백:', error);
            // 로컬 스토리지에서 토론 찾기 (폴백)
            discussion = localDiscussions.find(d => d.id == id);
        }

        if (!discussion) {
            console.error('토론을 찾을 수 없습니다:', id);
            showToast('토론 상세 정보를 불러올 수 없습니다.', 'error');
            hideLoading();
            return;
        }

        // 비밀글인 경우 입장코드 검증 (skipPrivateCheck가 true가 아닐 때만)
        if (discussion.is_private && !skipPrivateCheck) {
            console.log('비밀글 토론방 감지:', discussion.title);
            hideLoading();
            await showEntryCodeModal(id);
            return;
        }

        console.log('로컬 스토리지에서 토론 상세 정보 로드:', discussion);
        currentDiscussion = discussion;

        // Update modal content
        document.getElementById('detailTitle').textContent = discussion.title;
        document.getElementById('detailAuthor').textContent = `👤 ${discussion.author}`;
        document.getElementById('detailParticipants').textContent = `👥 ${discussion.participants}명`;
        document.getElementById('detailTimeRemaining').textContent = `⏰ ${discussion.timeRemaining}`;
        document.getElementById('detailType').textContent = discussion.type;
        document.getElementById('detailType').className = `type-badge ${discussion.type}`;
        document.getElementById('detailDescription').textContent = discussion.description || '설명이 없습니다.';

        // 서버에서 의견 로드
        await loadOpinions(discussion.id);

        discussionDetailModal.classList.add('active');
        document.body.style.overflow = 'hidden';

    } catch (error) {
        console.error('토론 상세 로드 오류:', error);
        showToast('토론 상세 정보를 불러올 수 없습니다.', 'error');
    } finally {
        hideLoading();
    }
}

function closeDiscussionDetailModal() {
    discussionDetailModal.classList.remove('active');
    document.body.style.overflow = '';
    currentDiscussion = null;

    // Reset opinion form
    document.getElementById('opinionForm').reset();

    // Reload discussions to update participant counts
    loadDiscussions();
}

function renderOpinions(opinions, type) {
    const container = document.getElementById(`${type}Opinions`);

    if (opinions.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">아직 의견이 없습니다.</p>';
        return;
    }

    container.innerHTML = opinions.map(opinion => `
        <div class="opinion-card">
            <div class="opinion-author">${escapeHtml(opinion.author)}</div>
            <div class="opinion-text">${escapeHtml(opinion.content)}</div>
            <div class="opinion-footer">
                <span>${formatTimeAgo(opinion.created_at)}</span>
                <button class="like-btn" onclick="likeOpinion(${opinion.id})">
                    <i class="fas fa-thumbs-up"></i>
                    ${opinion.likes_count}
                </button>
            </div>
        </div>
    `).join('');
}

// Form handlers
async function handleNewDiscussion(e) {
    e.preventDefault();

    // 기간 계산
    let duration;
    const durationSelect = document.getElementById('discussionDuration');
    if (durationSelect.value === 'custom') {
        const customDuration = document.getElementById('customDuration').value;
        duration = parseInt(customDuration) * 24; // 일을 시간으로 변환
    } else {
        duration = parseInt(durationSelect.value) * 24; // 일을 시간으로 변환
    }

    // 비밀글 설정 확인
    const isPrivate = document.getElementById('isPrivateDiscussion').checked;
    const entryCode = document.getElementById('entryCode').value.trim();

    const formData = {
        title: document.getElementById('discussionTitle').value.trim(),
        type: document.querySelector('input[name="discussionMode"]:checked').value,
        author: document.getElementById('discussionAuthor').value.trim(),
        password: document.getElementById('discussionPassword').value.trim(),
        description: document.getElementById('discussionDescription').value.trim(),
        duration: duration,
        prosName: document.getElementById('prosName')?.value || '찬성',
        consName: document.getElementById('consName')?.value || '반대',
        roleList: document.getElementById('roleList')?.value || '',
        isPrivate: isPrivate,
        entryCode: entryCode
    };

    if (!formData.title || !formData.author || !formData.password) {
        showToast('제목, 작성자, 비밀번호를 모두 입력해주세요.', 'error');
        return;
    }

    // 비밀글인 경우 입장코드 검증
    if (formData.isPrivate && (!formData.entryCode || formData.entryCode.length < 4)) {
        showToast('비밀글의 경우 4자리 이상의 입장코드를 설정해주세요.', 'error');
        return;
    }

    if (formData.type === 'custom' && !formData.duration) {
        showToast('사용자 입력 기간을 설정해주세요.', 'error');
        return;
    }

    try {
        showLoading();

        const discussionForm = document.getElementById('newDiscussionForm');
        const isEditMode = discussionForm.dataset.editMode === 'true';
        const editId = discussionForm.dataset.editId;

        if (isEditMode) {
            // 수정 모드
            try {
                const response = await fetch(`/api/discussions/${editId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                console.log('API를 통해 토론 수정 성공');

            } catch (apiError) {
                console.error('API 수정 실패, 로컬 스토리지 폴백:', apiError);

                // 로컬 스토리지에서 수정
                const index = localDiscussions.findIndex(d => d.id == editId);
                if (index > -1) {
                    localDiscussions[index] = {
                        ...localDiscussions[index],
                        ...formData,
                        expires_at: new Date(Date.now() + formData.duration * 60 * 60 * 1000)
                    };
                    localStorage.setItem('localDiscussions', JSON.stringify(localDiscussions));
                }
            }
        } else {
            // 생성 모드
            try {
                const response = await fetch('/api/discussions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log('API를 통해 토론 생성 성공:', result);

                // 비밀번호 저장
                localStorage.setItem(`discussion_${result.id}_password`, formData.password);

            } catch (apiError) {
                console.error('API 호출 실패, 로컬 스토리지 폴백:', apiError);

            // API 실패 시 로컬 스토리지 폴백
            const newDiscussion = {
                id: Date.now(),
                title: formData.title,
                type: formData.type,
                author: formData.author,
                description: formData.description,
                participants: 0,
                timeRemaining: `${formData.duration}시간 0분`,
                created_at: new Date(),
                expires_at: new Date(Date.now() + formData.duration * 60 * 60 * 1000),
                pros: [],
                cons: []
            };

                // 로컬 스토리지에 저장
                localDiscussions.unshift(newDiscussion);
                localStorage.setItem('localDiscussions', JSON.stringify(localDiscussions));

                // 비밀번호 저장
                localStorage.setItem(`discussion_${newDiscussion.id}_password`, formData.password);
            }
        }

        closeNewDiscussionModal();
        const formEl = document.getElementById('newDiscussionForm');
        const editModeActive = formEl.dataset.editMode === 'true';
        showToast(editModeActive ? '토론이 수정되었습니다!' : '새 토론이 생성되었습니다!', 'success');
        await loadDiscussions();

    } catch (error) {
        console.error('토론 생성 오류:', error);
        showToast('토론을 생성할 수 없습니다.', 'error');
    } finally {
        hideLoading();
    }
}

// OLD IMPLEMENTATION - Deprecated (localStorage only)
// Replaced by handleOpinionSubmit (line 1227) which uses PostgreSQL
/*
async function handleNewOpinion(e) {
    e.preventDefault();

    if (!currentDiscussion) {
        showToast('토론을 선택해주세요.', 'error');
        return;
    }

    const formData = {
        author: document.getElementById('opinionAuthor').value.trim(),
        content: document.getElementById('opinionContent').value.trim(),
        opinion_type: document.getElementById('opinionType').value
    };

    if (!formData.author || !formData.content || !formData.opinion_type) {
        showToast('모든 필드를 입력해주세요.', 'error');
        return;
    }

    try {
        showLoading();

        // 로컬 스토리지에서 토론 찾기
        const discussionIndex = localDiscussions.findIndex(d => d.id === currentDiscussion.id);
        if (discussionIndex === -1) {
            showToast('토론을 찾을 수 없습니다.', 'error');
            return;
        }

        // 새 의견 추가
        const newOpinion = {
            id: Date.now(),
            author: formData.author,
            content: formData.content,
            created_at: new Date(),
            likes_count: 0
        };

        // 찬성/반대에 따라 의견 추가
        if (formData.opinion_type === 'pros') {
            localDiscussions[discussionIndex].pros = localDiscussions[discussionIndex].pros || [];
            localDiscussions[discussionIndex].pros.unshift(newOpinion);
        } else {
            localDiscussions[discussionIndex].cons = localDiscussions[discussionIndex].cons || [];
            localDiscussions[discussionIndex].cons.unshift(newOpinion);
        }

        // 로컬 스토리지에 저장
        localStorage.setItem('localDiscussions', JSON.stringify(localDiscussions));

        showToast('의견이 추가되었습니다!', 'success');

        // Reset form
        document.getElementById('opinionForm').reset();

        // Reload discussion detail
        await openDiscussionDetail(currentDiscussion.id);

    } catch (error) {
        console.error('의견 추가 오류:', error);
        showToast('의견을 추가할 수 없습니다.', 'error');
    } finally {
        hideLoading();
    }
}
*/


async function likeOpinion(opinionId) {
    try {
        const result = await apiRequest(`/api/opinions/${opinionId}/like`, {
            method: 'POST'
        });

        showToast(result.message, 'success');

        // Reload discussion detail to update like counts
        if (currentDiscussion) {
            await openDiscussionDetail(currentDiscussion.id);
        }

    } catch (error) {
        console.error('좋아요 오류:', error);
        if (error.message.includes('이미')) {
            showToast('이미 좋아요를 누르셨습니다.', 'info');
        } else {
            showToast('좋아요를 추가할 수 없습니다.', 'error');
        }
    }
}

// Utility functions
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, (m) => map[m]);
}

function formatTimeAgo(dateString) {
    const now = new Date();
    const date = new Date(dateString);
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    if (diffMins < 1) return '방금 전';
    if (diffMins < 60) return `${diffMins}분 전`;
    if (diffHours < 24) return `${diffHours}시간 전`;
    return `${diffDays}일 전`;
}

// Toast notification
function showToast(message, type = 'info') {
    const toastIcon = toast.querySelector('.toast-icon');
    const toastMessage = toast.querySelector('.toast-message');

    // Reset classes
    toast.className = 'toast';

    // Set icon based on type
    switch (type) {
        case 'success':
            toastIcon.className = 'toast-icon fas fa-check-circle';
            toast.classList.add('success');
            break;
        case 'error':
            toastIcon.className = 'toast-icon fas fa-exclamation-circle';
            toast.classList.add('error');
            break;
        case 'info':
        default:
            toastIcon.className = 'toast-icon fas fa-info-circle';
            toast.classList.add('info');
            break;
    }

    toastMessage.textContent = message;
    toast.classList.add('show');

    // Auto hide after 3 seconds
    setTimeout(() => {
        toast.classList.remove('show');
    }, 3000);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // ESC to close modals
    if (e.key === 'Escape') {
        if (newDiscussionModal.classList.contains('active')) {
            closeNewDiscussionModal();
        }
        if (discussionDetailModal.classList.contains('active')) {
            closeDiscussionDetailModal();
        }
    }

    // Ctrl+K to focus search
    if (e.ctrlKey && e.key === 'k') {
        e.preventDefault();
        searchInput.focus();
    }

    // Ctrl+N to create new discussion
    if (e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        openNewDiscussionModal();
    }
});

// Smooth scrolling for internal links
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
            target.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
        }
    });
});

// Online/offline status
window.addEventListener('online', () => {
    showToast('인터넷 연결이 복구되었습니다.', 'success');
    loadDiscussions();
});

window.addEventListener('offline', () => {
    showToast('인터넷 연결이 끊어졌습니다.', 'error');
});

// Performance monitoring
if ('performance' in window) {
    window.addEventListener('load', () => {
        const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
        console.log(`페이지 로드 시간: ${loadTime}ms`);
    });
}

// 관리자 권한 확인
let isAdmin = localStorage.getItem('isAdmin') === 'true';

// 관리자 로그인 (콘솔에서 adminLogin('admin123') 호출)
window.adminLogin = function(password) {
    if (password === 'admin123') {
        isAdmin = true;
        localStorage.setItem('isAdmin', 'true');
        loadDiscussions(); // 카드 다시 렌더링
        showToast('관리자 권한이 활성화되었습니다.', 'success');
        return true;
    }
    showToast('잘못된 관리자 비밀번호입니다.', 'error');
    return false;
};

// 관리자 로그아웃
window.adminLogout = function() {
    isAdmin = false;
    localStorage.removeItem('isAdmin');
    loadDiscussions(); // 카드 다시 렌더링
    showToast('관리자 권한이 해제되었습니다.', 'info');
};

// 액션 버튼 렌더링
function renderActionButtons(discussion) {
    const buttons = [];

    // 수정 버튼 (작성자만)
    buttons.push(`
        <button class="edit-btn" onclick="editDiscussion(event, ${discussion.id})" title="토론 수정">
            <i class="fas fa-edit"></i>
        </button>
    `);

    // 삭제 버튼 (작성자 또는 관리자)
    if (isAdmin) {
        buttons.push(`
            <button class="delete-btn admin-delete" onclick="adminDeleteDiscussion(event, ${discussion.id})" title="관리자 삭제">
                <i class="fas fa-trash"></i>
            </button>
        `);
    } else {
        buttons.push(`
            <button class="delete-btn" onclick="deleteDiscussion(event, ${discussion.id})" title="토론 삭제">
                <i class="fas fa-times"></i>
            </button>
        `);
    }

    return buttons.join('');
}

// 토론 수정
function editDiscussion(event, discussionId) {
    event.stopPropagation();

    const discussion = currentDiscussions.find(d => d.id === discussionId);
    if (!discussion) return;

    // 작성자 확인
    const password = prompt('수정하려면 토론 생성 시 설정한 비밀번호를 입력하세요:');
    if (!password) return;

    // 실제로는 서버에서 비밀번호 확인해야 하지만, 여기서는 로컬스토리지에서 확인
    const savedPassword = localStorage.getItem(`discussion_${discussionId}_password`);
    if (savedPassword && savedPassword !== password) {
        showToast('비밀번호가 일치하지 않습니다.', 'error');
        return;
    }

    // 수정 모달 열기
    openEditModal(discussion);
}

// 관리자 삭제
function adminDeleteDiscussion(event, discussionId) {
    event.stopPropagation();

    if (!isAdmin) {
        showToast('관리자 권한이 필요합니다.', 'error');
        return;
    }

    const discussion = currentDiscussions.find(d => d.id === discussionId);
    if (!discussion) return;

    if (confirm(`관리자 권한으로 "${discussion.title}" 토론을 삭제하시겠습니까?`)) {
        performDeleteDiscussion(discussionId);
    }
}

// 일반 사용자 삭제 (비밀번호 확인)
function deleteDiscussion(event, discussionId) {
    event.stopPropagation();

    const discussion = currentDiscussions.find(d => d.id === discussionId);
    if (!discussion) return;

    const password = prompt('삭제하려면 토론 생성 시 설정한 비밀번호를 입력하세요:');
    if (!password) return;

    if (confirm(`"${discussion.title}" 토론을 삭제하시겠습니까?`)) {
        performDeleteDiscussion(discussionId, password);
    }
}

// 실제 삭제 수행
async function performDeleteDiscussion(discussionId, password) {
    try {
        showLoading();
        console.log('삭제 요청:', { discussionId, password });

        // API 호출
        const result = await apiRequest(`/api/discussions/${discussionId}`, {
            method: 'DELETE',
            body: JSON.stringify({ password: password })
        });

        console.log('삭제 성공:', result);
        showToast('토론이 삭제되었습니다.', 'success');
        await loadDiscussions();

    } catch (error) {
        console.error('삭제 오류:', error);
        showToast(error.message || '토론 삭제 중 오류가 발생했습니다.', 'error');
    } finally {
        hideLoading();
    }
}

// 수정 모달 열기
function openEditModal(discussion) {
    // 새 토론 모달을 수정용으로 재사용
    document.getElementById('discussionTitle').value = discussion.title;
    document.getElementById('discussionAuthor').value = discussion.author;
    document.getElementById('discussionDescription').value = discussion.description || '';

    // 토론 유형 설정
    const modeRadio = document.querySelector(`input[name="discussionMode"][value="${discussion.type}"]`);
    if (modeRadio) {
        modeRadio.checked = true;
        handleModeChange(); // 관련 섹션 표시/숨김
    }

    // 모달 타이틀 변경
    document.querySelector('#newDiscussionModal h2').textContent = '토론 수정하기';

    // 수정 모드 플래그 설정
    const editForm = document.getElementById('newDiscussionForm');
    editForm.dataset.editMode = 'true';
    editForm.dataset.editId = discussion.id;

    // 제출 버튼 텍스트 변경
    document.querySelector('#newDiscussionForm button[type="submit"]').textContent = '수정';

    openNewDiscussionModal();
}

// 모드 변경 처리
function handleModeChange() {
    const selectedMode = document.querySelector('input[name="discussionMode"]:checked').value;
    const prosConsSection = document.getElementById('prosConsSection');
    const roleSection = document.getElementById('roleSection');

    // 모든 섹션 숨기기
    prosConsSection.style.display = 'none';
    roleSection.style.display = 'none';

    // 선택된 모드에 따라 섹션 표시
    if (selectedMode === '팀전') {
        prosConsSection.style.display = 'block';
    } else if (selectedMode === '역할극') {
        roleSection.style.display = 'block';
    }
}

// 기간 선택 처리
function handleDurationChange() {
    const durationSelect = document.getElementById('discussionDuration');
    const customDurationSection = document.getElementById('customDurationSection');

    if (durationSelect.value === 'custom') {
        customDurationSection.style.display = 'block';
    } else {
        customDurationSection.style.display = 'none';
    }
}

// 비밀글 토글 핸들러
function handlePrivateToggle() {
    const privateToggle = document.getElementById('isPrivateDiscussion');
    const entryCodeSection = document.getElementById('entryCodeSection');

    if (privateToggle.checked) {
        entryCodeSection.style.display = 'block';
        // 입장코드 필수 입력 설정
        const entryCodeInput = document.getElementById('entryCode');
        entryCodeInput.required = true;
    } else {
        entryCodeSection.style.display = 'none';
        // 입장코드 필수 입력 해제
        const entryCodeInput = document.getElementById('entryCode');
        entryCodeInput.required = false;
        entryCodeInput.value = '';
    }
}

// 입장코드 모달 관련 변수
let pendingDiscussionId = null;

// 입장코드 모달 표시
async function showEntryCodeModal(discussionId) {
    pendingDiscussionId = discussionId;
    const modal = document.getElementById('entryCodeModal');
    const input = document.getElementById('entryCodeInput');
    input.value = '';
    modal.style.display = 'flex';
    input.focus();
}

// 입장코드 모달 닫기
function closeEntryCodeModal() {
    const modal = document.getElementById('entryCodeModal');
    modal.style.display = 'none';
    pendingDiscussionId = null;
}

// 입장코드 검증
async function verifyEntryCode() {
    if (!pendingDiscussionId) return;

    const entryCode = document.getElementById('entryCodeInput').value.trim();
    if (!entryCode) {
        showToast('입장코드를 입력하세요.', 'error');
        return;
    }

    try {
        showLoading();
        console.log('입장코드 검증 시작:', pendingDiscussionId, entryCode);

        const result = await apiRequest(`/api/discussions/${pendingDiscussionId}/verify-entry`, {
            method: 'POST',
            body: JSON.stringify({ entryCode })
        });

        console.log('입장코드 검증 성공:', result);

        // 검증 성공 후 토론방 열기 (비밀방 체크 건너뛰기)
        const discussionId = pendingDiscussionId;
        console.log('비밀방 열기 시도:', discussionId);

        closeEntryCodeModal();
        await openDiscussionDetail(discussionId, true);
    } catch (error) {
        console.error('입장코드 검증 오류:', error);
        showToast(error.message || '입장코드가 틀렸습니다.', 'error');
    } finally {
        hideLoading();
    }
}

// 자동 AI 설명 생성 (토론 제목 입력 시)
async function autoGenerateDescription(title) {
    const descriptionTextarea = document.getElementById('discussionDescription');

    // 이미 설명이 있으면 자동 생성하지 않음
    if (descriptionTextarea.value.trim()) {
        return;
    }

    try {
        const aiDescription = await generateAIDescriptionWithAPI(title);
        if (aiDescription) {
            descriptionTextarea.value = aiDescription;
        }
    } catch (error) {
        console.error('AI 자동 생성 실패:', error);
        // 실패 시 기본 설명 사용
        descriptionTextarea.value = `이 토론에서는 "${title}"에 대한 다양한 관점과 의견을 나누는 공간입니다.

참여자들은 자유롭게 자신의 생각을 표현하고, 서로의 의견을 존중하며 건설적인 대화를 나눌 수 있습니다.`;
    }
}

// AI 설명 생성 (버튼 클릭 시)
async function generateAIDescription() {
    const title = document.getElementById('discussionTitle').value.trim();
    const descriptionTextarea = document.getElementById('discussionDescription');

    if (!title) {
        showToast('토론 제목을 먼저 입력해주세요.', 'warning');
        return;
    }

    // AI 생성 애니메이션
    descriptionTextarea.value = '토론 상황을 생성하는 중...';
    descriptionTextarea.disabled = true;

    try {
        const aiDescription = await generateAIDescriptionWithAPI(title);
        descriptionTextarea.value = aiDescription || `이 토론에서는 "${title}"에 대한 다양한 관점과 의견을 나누는 공간입니다.

참여자들은 자유롭게 자신의 생각을 표현하고, 서로의 의견을 존중하며 건설적인 대화를 나눌 수 있습니다.`;
        showToast('AI가 토론 상황을 생성했습니다!', 'success');
    } catch (error) {
        console.error('AI 생성 실패:', error);
        descriptionTextarea.value = `이 토론에서는 "${title}"에 대한 다양한 관점과 의견을 나누는 공간입니다.

참여자들은 자유롭게 자신의 생각을 표현하고, 서로의 의견을 존중하며 건설적인 대화를 나눌 수 있습니다.`;
        showToast('AI 생성에 실패했습니다. 기본 설명을 사용합니다.', 'warning');
    } finally {
        descriptionTextarea.disabled = false;
    }
}

// Gemini API를 사용한 AI 설명 생성
async function generateAIDescriptionWithAPI(title) {
    // 서버에서 API 키 로드
    let API_KEY;
    try {
        const configResponse = await fetch('/api/config');
        const config = await configResponse.json();
        API_KEY = config.GEMINI_API_KEY;

        if (!API_KEY) {
            throw new Error('Gemini API 키가 설정되지 않았습니다.');
        }
    } catch (error) {
        console.error('API 설정 로드 실패:', error);
        throw new Error('API 설정을 불러올 수 없습니다.');
    }

    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;

    const prompt = `토론 주제: "${title}"

이 주제에 대한 토론 배경을 아래 형식대로 작성하세요:

【배경】
구체적인 사건이나 상황을 150자 이내로 간결하게 서술

【찬성 입장】
핵심 주장을 한 문장으로

【반대 입장】
핵심 주장을 한 문장으로

중요: 각 항목은 【 】로 시작하고 줄바꿈으로 구분`;

    try {
        const response = await fetch(API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }]
            })
        });

        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status}`);
        }

        const data = await response.json();

        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
            const generatedText = data.candidates[0].content.parts[0].text.trim();

            // AI 응답을 파싱하여 보고서 형식으로 포맷팅
            let formattedText = generatedText;

            // 불필요한 마크다운 제거
            formattedText = formattedText.replace(/\*\*/g, '');

            // 【 】 기호를 구조화된 형식으로 변경
            formattedText = formattedText.replace(/【배경】/g, '📋 상황:\n');
            formattedText = formattedText.replace(/【찬성 입장】/g, '\n\n✅ 찬성:\n');
            formattedText = formattedText.replace(/【반대 입장】/g, '\n\n❌ 반대:\n');

            // 각 섹션 사이에 구분선 추가
            formattedText = formattedText.replace(/(✅ 찬성:)/g, '━━━━━━━━━━━━━━━\n$1');
            formattedText = formattedText.replace(/(❌ 반대:)/g, '────────────\n$1');

            return formattedText.trim();
        } else {
            throw new Error('API 응답 형식이 올바르지 않습니다.');
        }
    } catch (error) {
        console.error('Gemini API 호출 실패:', error);
        throw error;
    }
}

// 의견 로드 함수
async function loadOpinions(discussionId) {
    try {
        const response = await fetch(`/api/discussions/${discussionId}/opinions`);
        if (!response.ok) throw new Error('의견을 불러올 수 없습니다');

        const opinions = await response.json();

        // 찬성/반대 의견 분리
        const prosOpinions = opinions.filter(op => op.opinion_type === 'pros');
        const consOpinions = opinions.filter(op => op.opinion_type === 'cons');

        // DOM 업데이트
        updateOpinionsDisplay(prosOpinions, consOpinions);
    } catch (error) {
        console.error('의견 로드 오류:', error);
    }
}

// 의견 표시 업데이트
function updateOpinionsDisplay(prosOpinions, consOpinions) {
    // 찬성 의견
    const prosContainer = document.getElementById('prosOpinions');
    const prosCount = document.getElementById('prosCount');
    if (prosContainer && prosCount) {
        prosCount.textContent = `${prosOpinions.length}개`;
        if (prosOpinions.length === 0) {
            prosContainer.innerHTML = '<p class="no-opinions">아직 의견이 없습니다.</p>';
        } else {
            prosContainer.innerHTML = prosOpinions.map(op => `
                <div class="opinion-item">
                    <div class="opinion-header">
                        <strong>${op.author}</strong>
                        <span class="opinion-time">${new Date(op.created_at).toLocaleString()}</span>
                    </div>
                    <p class="opinion-content">${op.content}</p>
                </div>
            `).join('');
        }
    }

    // 반대 의견
    const consContainer = document.getElementById('consOpinions');
    const consCount = document.getElementById('consCount');
    if (consContainer && consCount) {
        consCount.textContent = `${consOpinions.length}개`;
        if (consOpinions.length === 0) {
            consContainer.innerHTML = '<p class="no-opinions">아직 의견이 없습니다.</p>';
        } else {
            consContainer.innerHTML = consOpinions.map(op => `
                <div class="opinion-item">
                    <div class="opinion-header">
                        <strong>${op.author}</strong>
                        <span class="opinion-time">${new Date(op.created_at).toLocaleString()}</span>
                    </div>
                    <p class="opinion-content">${op.content}</p>
                </div>
            `).join('');
        }
    }
}

// 의견 제출
async function handleOpinionSubmit(e) {
    e.preventDefault();

    if (!currentDiscussion) {
        showToast('토론방 정보를 찾을 수 없습니다.', 'error');
        return;
    }

    const author = document.getElementById('opinionAuthor').value.trim();
    const content = document.getElementById('opinionContent').value.trim();
    const opinion_type = document.getElementById('opinionType').value;

    console.log('의견 제출 시도:', { author, content, opinion_type });

    if (!author || !content || !opinion_type) {
        console.error('유효성 검사 실패:', {
            author: !!author,
            content: !!content,
            opinion_type: !!opinion_type
        });
        showToast('모든 필드를 입력해주세요.', 'error');
        return;
    }

    try {
        const response = await fetch(`/api/discussions/${currentDiscussion.id}/opinions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ author, content, opinion_type })
        });

        if (response.ok) {
            showToast('의견이 추가되었습니다!', 'success');
            document.getElementById('opinionForm').reset();
            await loadOpinions(currentDiscussion.id);
        } else {
            const error = await response.json();
            throw new Error(error.error || '의견을 추가할 수 없습니다.');
        }
    } catch (error) {
        console.error('의견 추가 오류:', error);
        showToast(error.message, 'error');
    }
}

// 이벤트 리스너 등록
document.addEventListener('DOMContentLoaded', function() {
    const opinionForm = document.getElementById('opinionForm');
    if (opinionForm) {
        opinionForm.addEventListener('submit', handleOpinionSubmit);
    }
});

// Service Worker registration (for future PWA features)
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // navigator.serviceWorker.register('/sw.js')
        //     .then(registration => console.log('SW registered'))
        //     .catch(error => console.log('SW registration failed'));
    });
}